# -*- coding: utf-8 -*-
"""yolo_model.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1pfiMqzeuMPrNsKtA-YbqYLh-Pqhu3bp_
"""

from ultralytics import YOLO
from itertools import chain 
import cv2
from PIL import Image, ImageDraw, ImageFont
import numpy as np
import imageio
import json
import os


class NumpyEncoder(json.JSONEncoder):
    def default(self, obj):
        if isinstance(obj, np.ndarray):
            return obj.tolist()
        return json.JSONEncoder.default(self, obj)


class InferenceController():
    def __init__(self, model_name, source):
        self.model = self.load_pretrained_model(model_name)
        self.source = source
   
    def predict(self, *args, **kwargs):
        results = self.model.predict(self.source, *args, **kwargs)
        return self.results_to_json_format(results), self.get_labels_per_video(results)

    def results_to_json_format(self, results):
        json_results = {}

        for index, result in enumerate(results):
            json_results[index] = {
                "boxes": [[round(num, 4) for num in sublist] for sublist in result.boxes.xywh.tolist()] if len(result.boxes.xywh.tolist()) != 0 else None,
                "masks" : [[[round(float(val), 2)  for val in inner] for inner in mask] for mask in result.masks.xy] if result.masks is not None else None,
                "scores": [round(score, 4) for score in result.boxes.conf.tolist()] if len(result.boxes.conf.tolist())!=0 else None,
                "labels": result.boxes.cls.tolist() if len(result.boxes.cls.tolist())!=0 else None,
            }       
        return json_results
    
    def load_pretrained_model(self, model_name, task="segment"):
        return YOLO(model_name, task)  


    def get_labels_per_video(self, results):
        """
        This function returns a list of all unique classes that have appeared in this video.

        returns:
            A list of tuples, in the format: (class_id, class_name)
        """
        labels = self.get_labels_per_frame(results, results[0].names)
        labels = list(set((chain.from_iterable(labels))))
        return sorted(labels, key=lambda x: x[0])


    def get_labels_per_frame(self, results, unique=False):
        """
        This function returns a list of classes that have appeared in a single frame.

        params:
            unique: This parameter determines whether the classes in the return value will be unique or not. 

        returns:
            A list of tuples, in the format: (class_id, class_name)
        """
        labels = []
        all_labels = results[0].names
        temp = []

        if unique:
            for result in results:
                temp = [(num, all_labels[num]) for num in set(result.boxes.cls.tolist())]
        else:
            for result in results:
                temp =  [(num, all_labels[num]) for num in result.boxes.cls.tolist()]

        if len(temp) > 0:
            labels.append(temp)
        return sorted(labels, key=lambda x: x[0])
    

    def write_json_to_file(self, json_format_data, output_path):
        json_data = json.dumps(json_format_data, cls=NumpyEncoder)
        
        with open('data.json', 'w') as f:
            f.write(json_data)


# HOW TO USE
# inferenceController = InferenceController("C://Users//RaahimSiddiqi//Desktop//Code//VSC//VOS//Model//models//yolov8s-seg.pt", "C://Users//RaahimSiddiqi//Desktop//Code//VSC//VOS//Model//videos//input10.mp4")
# results, classes = inferenceController.predict(classes = [5])
# print(results, classes)


### Important Parameters for Prediction
# conf           	0.25	    object confidence threshold for detection
# iou	            0.7
# save	            False
# hide_labels	    False	    hide labels
# hide_conf	        False	    hide confidence scores
# classes	        None	    filter results by class, i.e. class=0, or class=[0,2,3]
# boxes	            True	    Show boxes in segmentation predictions

